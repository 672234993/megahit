#!/usr/bin/env python

#-------------------------------------------------------------------------
# MEGAHIT
# Copyright (C) 2014 - 2015 The University of Hong Kong
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#-------------------------------------------------------------------------

from __future__ import print_function

import sys
import getopt
import subprocess
import errno
import os, glob
import tempfile
import warnings
import shutil
import math  
import locale
import multiprocessing

from datetime import datetime, date, time

megahit_version_str = "MEGAHIT v1.0-alpha"
usage_message = '''
Copyright (c) The University of Hong Kong

Usage:
  megahit [options] {-r <se> | -1 <pe1> -2 <pe2> | --12 <pe12>} [-o <out_dir>]

    -r/--read                <se>           comma-separated list of single-end files
    -1                       <pe1>          comma-separated list of paired-end #1 files, paired with files in <pe2>
    -2                       <pe2>          comma-separated list of paired-end #2 files, paired with files in <pe1>
    --12                     <pe12>         comma-separated list of interleaved paired-end files

Optional Arguments:
  Hardware options:
    -m/--memory              <float>        max memory in byte to be used in SdBG construction; default 0.9
                                            (if set between 0-1, fraction of the machine's total memory)
    --mem-flag               <int>          SdBG builder memory mode, default 1
                                            0: minimum; 1: moderate; others: use all memory specified by '-m/--memory'.
    --use-gpu                               use GPU
    --gpu-mem                <float>        GPU memory in byte to be used. Default: auto detect to use up all free GPU memory. 
    -t/--num-cpu-threads     <int>          number of CPU threads, at least 2. Default: auto detect to use all CPU threads.
    --kmin-1pass                            use 1pass mode to build SdBG of k_min

  Output options:
    -o/--out-dir             <string>       output directory, default: ./megahit_out
    --out-prefix             <string>       output prefix (the contig file will be OUT_DIR/OUT_PREFIX.contigs.fa)
    --min-contig-len         <int>          minimum length of contigs to output, default: 200
    --keep-tmp-files                        keep all temporary files

  Basic assembly options:
    --k-min                  <int>          minimum kmer size (<= 127), must be odd number, default: 21
    --k-max                  <int>          maximum kmer size (<= 127), must be odd number, default: 99
    --k-step                 <int>          increment of kmer size of each iteration (<= 28), must be even number, default: 10
    --min-count              <int>          minimum multiplicity for filtering (k_min+1)-mers, default: 2.

  Advanced assembly options:
    --no-mercy                              do not add mercy kmers
    --no-bubble                             do not merge bubbles
    --merge-level            <int>          strength of complex bubble merging (0-100), default 20
    --prune-level            <int>          strength of local low depth pruning (0-2), default 2
    --low-local-ratio        <float>        ratio threshold to define low local coverage contigs, default: 0.2
    --max-tip-len            <int>          remove tips less than this value; default: 2*k for iteration of kmer_size=k
    --no-local                              disable local assembly

Other Arguments:
    --continue                              continue a MEGAHIT run from its last available check point.
                                            please set the output directory correctly when using this option.
    -h/--help                               print the usage message
    -v/--version                            print version
'''

if sys.version > '3':
    long = int

class Usage(Exception):
    def __init__(self, msg):
        self.msg = msg

class Options():
    def __init__(self):
        self.host_mem = 0.9
        self.gpu_mem = False
        self.lib = ""
        self.out_dir = "./megahit_out/"
        self.min_contig_len = 200
        self.k_min = 21
        self.k_max = 99
        self.k_step = 10
        self.min_count = 2
        self.bin_dir = sys.path[0] + "/"
        self.max_tip_len = -1
        self.no_mercy = False
        self.no_local = False
        self.no_bubble = False
        self.merge_level = 20
        self.prune_level = 2
        self.num_cpu_threads = False
        self.low_local_ratio = 0.2
        self.temp_dir = self.out_dir + "tmp/"
        self.keep_tmp_files = False
        self.builder = "sdbg_builder_cpu"
        self.use_gpu = False
        self.mem_flag = 1
        self.continue_mode = False;
        self.last_cp = -1;
        self.out_prefix = ""
        self.kmin_1pass = False
        self.pe1 = []
        self.pe2 = []
        self.pe12 = []
        self.se = []

opt = Options()
cp = 0

def log_file_name():
    if opt.out_prefix == "":
        return opt.out_dir + "log"
    else:
        return opt.out_dir + opt.out_prefix + ".log"

def opt_file_name():
    return opt.out_dir + "opts.txt"

def make_out_dir():
    if os.path.exists(opt.out_dir):
        pass
    else:
        os.mkdir(opt.out_dir)

    if os.path.exists(opt.temp_dir):
        pass
    else:
        os.mkdir(opt.temp_dir)

def parse_opt(argv):
    try:
        opts, args = getopt.getopt(argv, "hm:o:r:t:v1:2:", 
                                    ["help",
                                     "read=",
                                     "12=",
                                     "memory=",
                                     "out-dir=",
                                     "min-contig-len=",
                                     "cpu-only",
                                     "use-gpu",
                                     "num-cpu-threads=",
                                     "gpu-mem=",
                                     "kmin-1pass",
                                     "k-min=",
                                     "k-max=",
                                     "k-step=",
                                     "num-cpu-threads=",
                                     "min-count=",
                                     "no-mercy",
                                     "no-local",
                                     "max-tip-len=",
                                     "no-bubble",
                                     "prune-level=",
                                     "merge-level=",
                                     "low-local-ratio=",
                                     "keep-tmp-files",
                                     "mem-flag=",
                                     "continue",
                                     "version",
                                     "out-prefix="])
    except getopt.error as msg:
        raise Usage(megahit_version_str + '\n' + str(msg))
    if len(opts) == 0:
        raise Usage(megahit_version_str + '\n' + usage_message)

    global opt
    need_continue = False

    for option, value in opts:
        if option in ("-h", "--help"):
            raise Usage(megahit_version_str + '\n' + usage_message)
        elif option in ("-o", "--out-dir"):
            if opt.continue_mode == 0:
                opt.out_dir = value + "/"
        elif option in ("-m", "--memory"):
            opt.host_mem = float(value)
        elif option == "--gpu-mem":
            opt.gpu_mem = long(float(value))
        elif option == "--min-contig-len":
            opt.min_contig_len = int(value)
        elif option in ("-t", "--num-cpu-threads"):
            opt.num_cpu_threads = int(value)
        elif option == "--kmin-1pass":
            opt.kmin_1pass = True
        elif option == "--lib":
            opt.lib = value
        elif option == "--k-min":
            opt.k_min = int(value)
        elif option == "--k-max":
            opt.k_max = int(value)
        elif option == "--k-step":
            opt.k_step = int(value)
        elif option == "--min-count":
            opt.min_count = int(value)
        elif option == "--max-tip-len":
            opt.max_tip_len = int(value)
        elif option == "--merge-level":
            opt.merge_level = int(value)
        elif option == "--prune-level":
            opt.prune_level = int(value)
        elif option == "--no-bubble":
            opt.no_bubble = True
        elif option == "--no-mercy":
            opt.no_mercy = True
        elif option == "--no-local":
            opt.no_local = True
        elif option == "--low-local-ratio":
            opt.low_local_ratio = float(value)
        elif option == "--keep-tmp-files":
            opt.keep_tmp_files = True
        elif option == "--use-gpu":
            opt.use_gpu = True
            opt.builder = "sdbg_builder_gpu"
        elif option == "--mem-flag":
            opt.mem_flag = int(value)
        elif option in ("-v", "--version"):
            print(megahit_version_str)
            exit(0)
        elif option == "--continue":
            if opt.continue_mode == 0: # avoid check again again again...
                need_continue = True
        elif option == "--out-prefix":
            opt.out_prefix = value
        elif option in ("--cpu-only", "-l", "--max-read-len", "--no-low-local"):
            continue # historical options, just ignore
        elif option in ("-r", "--read"):
            opt.se = value.split(",")
        elif option == "-1":
            opt.pe1 = value.split(",")
        elif option == "-2":
            opt.pe2 = value.split(",")
        elif option == "--12":
            opt.pe12 = value.split(",")

        else:
            print("Invalid option %s", option, file=sys.stderr)
            exit(1)

    opt.temp_dir = opt.out_dir + "tmp/"

    if need_continue:
        prepare_continue()
    elif opt.continue_mode == 0 and os.path.exists(opt.out_dir):
        print("Output directory " + opt.out_dir + " already exists, please change the parameter -o to another value to avoid overwriting.", file=sys.stderr)
        exit(1)

def check_opt():
    global opt
    if opt.host_mem <= 0:
        raise Usage("Please specify a positive number for -m flag.")
        exit(1)
    elif opt.host_mem < 1:
        total_mem = detect_available_mem()
        opt.host_mem = long(total_mem * opt.host_mem)
        if total_mem <= 0:
            raise Usage("Failed to detect available memory. Please specify the value in bytes using -m flag.")
            exit(1)
        else:
            print(str(round(total_mem/(1024**3),3)) + "Gb memory in total.", file=sys.stderr)
            print("Using: " + str(round(float(opt.host_mem)/(1024**3),3)) + "Gb.", file=sys.stderr)
    else:
        opt.host_mem = long(opt.host_mem)
    if opt.use_gpu == 0:
        opt.gpu_mem = 0
    if opt.lib != "" and not os.path.exists(opt.lib):
        raise Usage("Can't find file:\n" + opt.lib + "\nPlease try a valid file with -r option.", file=sys.stderr)
    if opt.k_min < 15:
        raise Usage("k_min should be at least 15.")
    if opt.k_max > 127:
        raise Usage("k_max cannot exceed 127.")
    if opt.k_max < opt.k_min:
        raise Usage("k_min should be no larger than k_max.")
    if opt.k_min % 2 == 0 or opt.k_max % 2 == 0:
        raise Usage("k_min and k_max must be odd numbers.")
    if opt.k_step > 28:
        raise Usage("step must be less than 29.")
    if opt.k_step % 2 != 0:
        raise Usage("step must be an even number.")
    if opt.min_count <= 0:
        raise Usage("min_count must be greater than 0.")
    if opt.prune_level < 0 or opt.prune_level > 2:
        raise Usage("prune level must be in 0-2.")
    if opt.merge_level < 0 or opt.merge_level > 100:
        raise Usage("merge level must be in 0-100.")
    if opt.low_local_ratio <= 0 or opt.low_local_ratio > 0.5:
        raise Usage("low_local_ratio should be in (0, 0.5].")
    if opt.num_cpu_threads > multiprocessing.cpu_count():
        print("Maximum number of available CPU thread is %d." % multiprocessing.cpu_count(), file=sys.stderr);
        print("Number of thread is reset to the %d." % max(2, multiprocessing.cpu_count()), file=sys.stderr);
        opt.num_cpu_threads = multiprocessing.cpu_count()
    if opt.num_cpu_threads == 0:
        opt.num_cpu_threads = multiprocessing.cpu_count()
    if opt.num_cpu_threads <= 1:
        raise Usage("num_cpu_threads should be at least 2.")

    # reads
    if len(opt.pe1) != len(opt.pe2):
        raise Usage("Number of paired-end files not match!")
    for r in opt.pe1 + opt.pe2 + opt.se + opt.pe12:
        if not os.path.exists(r):
            raise Usage("Cannot find file " + r)

def detect_available_mem():
    mem = long()
    if sys.platform.find("linux") != -1:
        try:
            mem = long(float(os.popen("free").readlines()[1].split()[1]) * 1024)
        except IndexError:
            mem = 0
    elif sys.platform.find("darwin") != -1:
        try:
            mem = long(float(os.popen("sysctl hw.memsize").readlines()[0].split()[1]))
        except IndexError:
            mem = 0
    else:
        mem = 0
    return mem

def write_opt(argv):
    with open(opt_file_name(), "w") as f:
        print("\n".join(argv), file=f)
    f.close()

def prepare_continue():
    global opt # out_dir is already set
    if not os.path.exists(opt_file_name()):
        print("Cannot find " + opt.out_dir + "opts.txt", file=sys.stderr)
        print("Please check whether the output directory is correctly set by \"-o\"", file=sys.stderr)
        print("Now switching to normal mode.", file=sys.stderr)
        return

    print("Continue mode activated. Ignore all options other than -o/--out-dir.", file=sys.stderr)

    with open(opt_file_name(), "r") as f:
        argv = []
        for line in f:
            argv.append(line.strip())
        print("Continue with options: " + " ".join(argv), file=sys.stderr)
        t_dir = opt.out_dir
        opt = Options()
        opt.out_dir = t_dir
        opt.continue_mode = True # avoid dead loop
        parse_opt(argv)
    f.close()

    opt.last_cp = -1
    if os.path.exists(opt.temp_dir + "cp.txt"):
        with open(opt.temp_dir + "cp.txt", "r") as cpf:
            for line in cpf:
                a = line.strip().split()
                if len(a) == 2 and a[1] == "done":
                    opt.last_cp = int(a[0])
        cpf.close()
    print("Continue from check point " + str(opt.last_cp), file=sys.stderr) 

def check_bin():
    for subprogram in ["megahit_assemble", "megahit_iter", "megahit_local_asm"]:
        if not os.path.exists(opt.bin_dir + "megahit_assemble"):
            raise Usage(megahit_version_str + '\n' + "Cannot find sub-program \"" + subprogram + "\", please recompile.")

def check_builder():
    if not os.path.exists(opt.bin_dir + opt.builder):
        print(megahit_version_str + '\n' + "Cannot find sub-program \"%s\", please recompile." % opt.builder, file=sys.stderr)
        if opt.use_gpu == 0:
            print("Or if you want to use the GPU version, please run MEGAHIT with \"--use-gpu\"", file=sys.stderr)
        exit(1)

def graph_prefix(kmer_k):
    return opt.temp_dir + "k" + str(kmer_k)

def delect_file_if_exist(file_name):
    if os.path.exists(file_name):
        os.remove(file_name)

def delete_tmp_after_build(kmer_k):
    for i in range(0, max(1, int(opt.num_cpu_threads / 3))):
        delect_file_if_exist(graph_prefix(kmer_k) + ".edges." + str(i))
    for i in range(0, 64):
        delect_file_if_exist(graph_prefix(kmer_k) + ".mercy_cand." + str(i))
    for i in range(0, opt.num_cpu_threads - 1):
        delect_file_if_exist(graph_prefix(kmer_k) + ".mercy." + str(i))
    delect_file_if_exist(graph_prefix(kmer_k) + ".cand")

def delete_tmp_after_assemble(kmer_k):
    for extension in ["w", "last", "isd", "dn", "f", "mul", "mul2"]:
        delect_file_if_exist(graph_prefix(kmer_k) + "." + extension)

def delete_tmp_after_iter(kmer_k):
    delect_file_if_exist(graph_prefix(kmer_k) + ".rr.pb")

def write_cp(cp):
    cpf = open(opt.temp_dir + "cp.txt", "a")
    print(str(cp) + "\t" + "done", file=cpf);
    cpf.close()

def write_lib():
    opt.lib = opt.temp_dir + "reads.lib"
    lib = open(opt.lib, "w")
    for r in opt.pe12:
        print("interleaved " + r, file=lib)
    for i in range(0, len(opt.pe1)):
        print("pe " + opt.pe1[i] + " " + opt.pe2[i], file=lib)
    for r in opt.se:
        print("se " + r, file=lib)
    lib.close()

def build_first_graph():
    global cp
    phase1_out_threads = max(1, int(opt.num_cpu_threads / 3))
    if (not opt.continue_mode) or (cp > opt.last_cp):
        count_opt = ["-k", str(opt.k_min),
                     "-m", str(opt.min_count),
                     "--host_mem", str(opt.host_mem),
                     "--mem_flag", str(opt.mem_flag),
                     "--gpu_mem", str(opt.gpu_mem),
                     "--output_prefix", graph_prefix(opt.k_min),
                     "--num_cpu_threads", str(opt.num_cpu_threads),
                     "--num_output_threads", str(phase1_out_threads),
                     "--read_lib_file", str(opt.lib)]

        cmd = []
        if opt.kmin_1pass:
            cmd = [opt.bin_dir + opt.builder, "read2sdbg"] + count_opt
            if opt.no_mercy == 0:
                cmd.append("--need_mercy")
        else:
            cmd = [opt.bin_dir + opt.builder, "count"] + count_opt

        try:
            log_file = open(log_file_name(), "a")
            start_time = datetime.now()
            print("%s" % (" ").join(cmd), file=log_file)
            if opt.kmin_1pass:
                print("[%s] Extracting solid (k+1)-mers and building sdbg for k = %d" % (start_time.strftime("%c"), opt.k_min), file=sys.stderr)
                print("[%s] Extracting solid (k+1)-mers and building sdbg k = %d" % (start_time.strftime("%c"), opt.k_min), file=log_file)
            else:
                print("[%s] Extracting solid (k+1)-mers for k = %d" % (start_time.strftime("%c"), opt.k_min), file=sys.stderr)
                print("[%s] Extracting solid (k+1)-mers for k = %d" % (start_time.strftime("%c"), opt.k_min), file=log_file)
            log_file.flush()

            ret_code = subprocess.call(cmd, stdout = log_file)
            if ret_code != 0:
                print("Error occurs when running \"sdbg_builder count/read2sdbg\"", file=sys.stderr)
                print("[Exit code %d] " % ret_code, file=sys.stderr)
                exit(ret_code)
            log_file.close()

        except OSError as o:
            if o.errno == errno.ENOTDIR or o.errno == errno.ENOENT:
                print("Error: sub-program sdbg_builder not found, please recompile MEGAHIT", file=sys.stderr)
            exit(1)

    write_cp(cp)
    cp = cp + 1
    if not opt.kmin_1pass:
        build_graph(opt.k_min, opt.k_min, phase1_out_threads)
    elif not opt.keep_tmp_files:
        delete_tmp_after_build(opt.k_min)

def build_graph(kmer_k, kmer_from, num_edge_files):
    global cp
    if (not opt.continue_mode) or (cp > opt.last_cp):
        if os.path.getsize(graph_prefix(kmer_k) + ".edges.0") == 0:
            return False # not build
        build_comm_opt = ["--host_mem", str(opt.host_mem),
                             "--mem_flag", str(opt.mem_flag),
                             "--gpu_mem", str(opt.gpu_mem),
                             "--input_prefix", graph_prefix(kmer_k),
                             "--output_prefix", graph_prefix(kmer_k),
                             "--num_cpu_threads", str(opt.num_cpu_threads),
                             "-k", str(kmer_k), 
                             "--kmer_from", str(kmer_from),
                             "--num_edge_files", str(num_edge_files)]

        build_cmd = [opt.bin_dir + opt.builder, "seq2sdbg"] + build_comm_opt

        if (os.path.exists(graph_prefix(kmer_from) + ".contigs.fa")):
            build_cmd += ["--contig", graph_prefix(kmer_from) + ".contigs.fa"]
        if (os.path.exists(graph_prefix(kmer_from) + ".addi.fa")):
            build_cmd += ["--addi_contig", graph_prefix(kmer_from) + ".addi.fa"]
        if (os.path.exists(graph_prefix(kmer_from) + ".local.fa")):
            build_cmd += ["--local_contig", graph_prefix(kmer_from) + ".local.fa"]

        if (opt.no_mercy == 0 and kmer_k == opt.k_min):
            build_cmd.append("--need_mercy")

        try:
            log_file = open(log_file_name(), "a")
            start_time = datetime.now()
            print("%s" % (" ").join(build_cmd), file=log_file)
            print("[%s] Building graph for k = %d" % (start_time.strftime("%c"), kmer_k), file=sys.stderr)
            print("[%s] Building graph for k = %d" % (start_time.strftime("%c"), kmer_k), file=log_file)
            log_file.flush()
            ret_code = subprocess.call(build_cmd, stdout = log_file)
            if ret_code != 0:
                print("Error occurs when running \"builder build\" for k = %d" % kmer_k, file=sys.stderr)
                print("[Exit code %d]" % ret_code, file=sys.stderr)
                exit(ret_code)
            log_file.close()
        except OSError as o:
            if o.errno == errno.ENOTDIR or o.errno == errno.ENOENT:
                print("Error: sub-program builder not found, please recompile MEGAHIT", file=sys.stderr)
            exit(1) 

    write_cp(cp)
    cp = cp + 1
    if not opt.keep_tmp_files:
        delete_tmp_after_build(kmer_k)
    return True

def iterate(cur_k, step):
    global cp
    if (not opt.continue_mode) or (cp > opt.last_cp):
        next_k = cur_k + step
        iterator = opt.bin_dir + "megahit_iter"

        iterate_cmd = [iterator,
                       "-c", graph_prefix(cur_k) + ".contigs.fa",
                       "-t", str(opt.num_cpu_threads),
                       "-k", str(cur_k),
                       "-s", str(step),
                       "-o", graph_prefix(next_k),
                       "-r", graph_prefix(opt.k_min) + ".all_reads.bin",
                       "-f", "binary"]

        try:
            log_file = open(log_file_name(), "a")
            start_time = datetime.now()
            print("%s" % (" ").join(iterate_cmd), file=log_file)
            print("[%s] Extracting iterative edges from k = %d to %d" % (start_time.strftime("%c"), cur_k, next_k), file=sys.stderr)
            print("[%s] Extracting iterative edges from k = %d to %d" % (start_time.strftime("%c"), cur_k, next_k), file=log_file)
            log_file.flush()
            ret_code = subprocess.call(iterate_cmd, stdout = log_file)
            if ret_code != 0:
                print("Error occurs when running iterator for k = %d to k = %d " % (cur_k, next_k), file=sys.stderr)
                print("[Exit code %d]" % ret_code, file=sys.stderr)
                exit(ret_code)

            log_file.close()

        except OSError as o:
            if o.errno == errno.ENOTDIR or o.errno == errno.ENOENT:
                print("Error: sub-program megahit_iter not found, please recompile MEGAHIT", file=sys.stderr)
            exit(1)

    write_cp(cp)
    cp = cp + 1
    if not opt.keep_tmp_files:
        delete_tmp_after_iter(cur_k)

def assemble(cur_k):
    global cp
    if (not opt.continue_mode) or (cp > opt.last_cp):
        assembly_cmd = [opt.bin_dir + "megahit_assemble",
                        "-s", graph_prefix(cur_k),
                        "-o", graph_prefix(cur_k),
                        "-t", str(opt.num_cpu_threads),
                        "--max_tip_len", str(opt.max_tip_len),
                        "--min_final_len", str(opt.min_contig_len),
                        "--prune_level", str(opt.prune_level),
                        "--merge_level", str(opt.merge_level)]

        if cur_k == opt.k_min:
            assembly_cmd.append("--min_depth")
            assembly_cmd.append(str(opt.min_count))
        else:
            assembly_cmd.append("--min_depth")
            assembly_cmd.append("1.5")

        if cur_k == opt.k_max:
            assembly_cmd.append("--is_final_round")

        if opt.no_bubble:
            assembly_cmd.append("--no_bubble")

        try:
            log_file = open(log_file_name(), "a")
            start_time = datetime.now()
            print("%s" % (" ").join(assembly_cmd), file=log_file)
            print("[%s] Assembling contigs from SdBG for k = %d" % (start_time.strftime("%c"), cur_k), file=sys.stderr)
            print("[%s] Assembling contigs from SdBG for k = %d" % (start_time.strftime("%c"), cur_k), file=log_file)
            log_file.flush()
            ret_code = subprocess.call(assembly_cmd, stdout = log_file)
            if ret_code != 0:
                print("Error occurs when assembling contigs for k = %d" % cur_k, file=sys.stderr)
                print("[Exit code %d]" % ret_code, file=sys.stderr)
                exit(ret_code)

            log_file.close()
            
        except OSError as o:
            if o.errno == errno.ENOTDIR or o.errno == errno.ENOENT:
                print("Error: sub-program megahit_assemble not found, please recompile MEGAHIT", file=sys.stderr)
            exit(1)
    write_cp(cp)
    cp = cp + 1
    if (not opt.keep_tmp_files) and (cur_k != opt.k_max):
        delete_tmp_after_assemble(cur_k)

def local_assemble(cur_k):
    global cp
    if (not opt.continue_mode) or (cp > opt.last_cp):
        la_cmd = [opt.bin_dir + "megahit_local_asm",
                  "-c", graph_prefix(cur_k) + ".contigs.fa",
                  "-l", graph_prefix(opt.k_min) + ".all_reads",
                  "-t", str(opt.num_cpu_threads),
                  # "--sparsity", "1",
                  "--kmax", str(min(cur_k + opt.k_step, opt.k_max))]
        try:
            log_file = open(log_file_name(), "a")
            start_time = datetime.now()
            print("%s" % (" ").join(la_cmd), file=log_file)
            print("[%s] Local assembling k = %d" % (start_time.strftime("%c"), cur_k), file=sys.stderr)
            print("[%s] Local assembling k = %d" % (start_time.strftime("%c"), cur_k), file=log_file)
            log_file.flush()

            local_contig_file = open(graph_prefix(cur_k) + ".local.fa", "w")
            ret_code = subprocess.call(la_cmd, stdout = local_contig_file)
            if ret_code != 0:
                print("Error occurs when running local assembly for k = %d to k = %d " % (cur_k, next_k), file=sys.stderr)
                print("[Exit code %d]" % ret_code, file=sys.stderr)
                exit(ret_code)

            local_contig_file.close();
            log_file.close()

        except OSError as o:
            if o.errno == errno.ENOTDIR or o.errno == errno.ENOENT:
                print("Error: sub-program megahit_local_asm not found, please recompile MEGAHIT", file=sys.stderr)
            exit(1)

    write_cp(cp)
    cp = cp + 1

def merge_final():
    log_file = open(log_file_name(), "a")
    start_time = datetime.now()
    print("[%s] Merging to output final contigs." % (start_time.strftime("%c")), file=sys.stderr)
    print("[%s] Merging to output final contigs.." % (start_time.strftime("%c")), file=log_file)
    final_contig_name = opt.out_dir + "final.contigs.fa"
    if opt.out_prefix != "":
        final_contig_name = opt.out_dir + opt.out_prefix + ".contigs.fa"
    os.system("cat " + opt.temp_dir + "*.final.contigs.fa > " + final_contig_name)
    os.system("cat " + graph_prefix(opt.k_max) + ".contigs.fa >> " + final_contig_name)

    log_file.flush()
    log_file.close()

def main(argv = None):
    if argv is None:
        argv = sys.argv

    try:
        check_bin()
        parse_opt(argv[1:])
        check_opt()
        check_builder()

        start_time = datetime.now()  
        print(megahit_version_str, file=sys.stderr)
        print("[%s] Start assembly. Number of CPU threads %d." % (start_time.strftime("%c"), opt.num_cpu_threads), file=sys.stderr)

        make_out_dir()
        write_lib()

        if not opt.continue_mode:
            write_opt(argv[1:]) # for --continue
        build_first_graph()
        assemble(opt.k_min)

        k_step = opt.k_step
        cur_k = opt.k_min
        while cur_k < opt.k_max:
            if not opt.no_local:
                local_assemble(cur_k)
            next_k = min(cur_k + k_step, opt.k_max)
            if next_k > opt.k_max:
                k_step = opt.k_max - cur_k
                next_k = opt.k_max

            iterate(cur_k, next_k - cur_k)

            if not build_graph(next_k, cur_k, 1):
                cur_k = next_k
                break
            assemble(next_k)
            cur_k = next_k
        # end while

        merge_final()

        log_file = open(log_file_name(), "a")
        start_time = datetime.now()
        print("[%s] ALL DONE." % (start_time.strftime("%c")), file=sys.stderr)
        print("[%s] ALL DONE." % (start_time.strftime("%c")), file=log_file)
        log_file.flush()
        log_file.close()
        open(opt.out_dir + "done", "w").close()

    except Usage as err:
        print(sys.argv[0].split("/")[-1] + ": " + str(err.msg), file=sys.stderr)
        return 2

if __name__ == "__main__":
    sys.exit(main())
